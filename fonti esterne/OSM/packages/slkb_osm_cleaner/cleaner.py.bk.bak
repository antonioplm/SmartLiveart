from .mappings import GENERIC_NAMES

def is_generic(name: str) -> bool:
    """Verifica se il nome Ã¨ generico (es. 'Park', 'Bar', 'Farmacia', ecc.)"""
    if not name:
        return False
    return name.strip().lower() in GENERIC_NAMES


def normalize_name(name: str, indirizzo: str = "", categoria: str = "", quartiere: str = "") -> str:
    """
    Normalizza i nomi generici (es. 'Farmacia', 'Bar', 'Pizzeria') arricchendoli con
    informazioni come indirizzo, quartiere o categoria.
    """
    n = name.strip()
    if not is_generic(n):
        return n

    base_name = n.capitalize()
    via = indirizzo.split(",")[0].strip() if indirizzo else ""
    quart = quartiere.strip() if quartiere else ""

    # Costruzione dinamica del nome
    if via and quart:
        return f"{base_name} ({via}, {quart})"
    elif via:
        return f"{base_name} ({via})"
    elif quart:
        return f"{base_name} â€” {quart}"
    elif categoria:
        return f"{base_name} â€” {categoria}"
    else:
        return base_name

def apply_name_cleaning(poi):
    """
    Normalizza nome_poi usando address/tag.
    Gestisce:
    - Traduzioni inglese â†’ italiano
    - Fermate autobus/treno/tram/metro/funicolare
    - Togli cittÃ  dal nome
    - Evita duplicazioni
    - Aggiunge indirizzo solo quando necessario
    - Gestione ferrovie nazionali RFI con rfi_count
    - Pulizia e capitalizzazione finale
    """

    import re
    import unicodedata
    from difflib import SequenceMatcher

    name = (poi.get("nome_poi") or "").strip()
    tag = (poi.get("tag_k3") or "").lower()
    categoria = (poi.get("categoria_persistente") or "").strip()
    address = (poi.get("address") or "").strip()
    city = (poi.get("citta_comune") or "").strip()

    # -----------------------------------
    # Traduzione categorie inglesi â†’ italiane SOLO quando il nome Ã¨ generico
    # -----------------------------------
    EN_TO_IT = {
        "parking": "Parcheggio", "restaurant": "Ristorante", "bar": "Bar",
        "cafe": "CaffÃ¨", "fast food": "Fast food", "hotel": "Hotel",
        "guest house": "Affittacamere", "bed & breakfast": "B&B",
        "pharmacy": "Farmacia", "bank": "Banca", "atm": "Bancomat",
        "post office": "Ufficio postale", "post_office": "Ufficio postale",
        "theatre": "Teatro", "cinema": "Cinema", "viewpoint": "Belvedere",
        "platform": "Piattaforma", "stop": "Fermata", "station": "Stazione",
        "park": "Parco", "hospital": "Ospedale", "clinic": "Clinica",
        "school": "Scuola", "university": "UniversitÃ ", "library": "Biblioteca",
        "museum": "Museo", "supermarket": "Supermercato", "marketplace": "Mercato",
        "church": "Chiesa", "chapel": "Cappella",
    }

    name_clean = name.lower().replace("_", " ").strip()

    for en, it in EN_TO_IT.items():
        if name_clean == en:
            name = it
            break
        if name_clean.startswith(en + " "):
            name = re.sub(rf"(?i)^{en}\b", it, name, 1)
            break

    # -----------------------------------
    # Address â†’ normalizzato senza CAP e cittÃ 
    # -----------------------------------
    def clean_address_for_name(addr):
        if not addr:
            return ""
        a = re.sub(r"\b\d{5}\b", "", addr)
        if city:
            a = re.sub(rf"(?i)\b{re.escape(city)}\b", "", a)
        a = re.sub(r"[()]", "", a)
        a = re.sub(r"\s{2,}", " ", a)
        return a.strip(" ,")

    city_normalized = city.strip()
    via_clean_short = clean_address_for_name(address)

    # -----------------------------------
    # Utility
    # -----------------------------------
    def normalize_for_match(s):
        s = (s or "").lower()
        s = ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn')
        return re.sub(r"[^a-z0-9 ]+", " ", s).strip()

    def strip_city_from_name(name_str, city_str):
        if not city_str:
            return name_str
        n = re.sub(rf"(?i)^\s*{re.escape(city_str)}\s*[-,â€“:]?\s*", "", name_str.strip())
        n = re.sub(rf"(?i)\s*[-,â€“:]\s*{re.escape(city_str)}\s*$", "", n)
        return n.strip()

    def fix_initials_in_name(s: str) -> str:
        if not s:
            return s
        import re
        def repl_multi(m):
            initials = m.group(1)
            rest = m.group(2) or ""
            inits = [c.upper() + "." for c in re.findall(r"([A-Za-z])\.", initials)]
            rest_fixed = smart_capitalize(rest.strip()) if rest else ""
            return (" ".join(inits) + (" " + rest_fixed if rest_fixed else "")).strip()
        s = re.sub(r'\b((?:[A-Za-z]\.){2,})(?:\s*|\s*)([A-Za-z][\w\'\-\s]*)', repl_multi, s)

        def repl_single(m):
            init = m.group(1).upper() + "."
            rest = m.group(2) or ""
            rest_fixed = smart_capitalize(rest.strip()) if rest else ""
            return (init + (" " + rest_fixed if rest_fixed else "")).strip()
        s = re.sub(r'\b([A-Za-z])\.\s*([A-Za-z][\w\'\-]*)', repl_single, s)

        return s

    def smart_capitalize(s: str) -> str:
        if not s:
            return s

        exceptions = {"di", "del", "della", "dei", "da", "e", "a", "al", "ai", "alle", "degli", "delle", "nel", "sul", "sulla"}

        def cap_word(w):
            # Caso: iniziale puntata â†’ es. "c.bilotti" â†’ "C. Bilotti"
            if "." in w and len(w) <= 6:  # evita casi tipo "S.alessandro" errati
                parts = w.split(".")
                parts = [p for p in parts if p]  # rimuove eventuali pezzi vuoti
                if len(parts) == 2 and len(parts[0]) == 1:  # Es. C.Bilotti
                    # iniziale â†’ maiuscola + punto + cognome capitalizzato
                    iniziale = parts[0].upper() + "."
                    cognome = parts[1].capitalize()
                    return f"{iniziale} {cognome}"

            # Caso normale
            w_low = w.lower()
            return w_low.capitalize()

        words = s.split()
        result = []
        for i, w in enumerate(words):
            w_clean = w.lower()
            if i != 0 and w_clean in exceptions:
                result.append(w_clean)
            else:
                result.append(cap_word(w))

        return " ".join(result)

    # ============================================================
    # ðŸš† BLOCCO TRASPORTO PUBBLICO (con riconoscimento ferrovia suburbana)
    # ============================================================
    def parse_tag_dict(tag_str):
        d = {}
        for p in tag_str.split(";"):
            if "=" in p:
                k, v = p.split("=", 1)
                d[k.strip().lower()] = v.strip().lower()
        return d

    tag_dict = parse_tag_dict(tag)

    FERROVIA_SUBURBANA_KEYWORDS = [
        "circumvesuviana", "eav",
        "trenord", "ferrovienord", "ferrovie nord", "fnm",
        "ferrovie appulo lucane", "ferrovie appulo-lucane", "fal",
        "ferrovie della calabria", "ferrovie calabria", "fcal",
        "ferrovie sud est", "fse",
        "romaâ€“viterbo", "roma-viterbo", "roma viterbo"
    ]

    def is_suburban_rail(name_str, tag_info):
        base = (name_str or "").lower() + " " + tag_info.get("operator", "") + " " + tag_info.get("network", "")
        return any(k in base.lower() for k in FERROVIA_SUBURBANA_KEYWORDS)

    if any(k in tag for k in [
        "public_transport=", "highway=bus_stop", "bus=yes",
        "railway=", "train=yes", "tram=yes", "light_rail=yes",
        "subway=yes", "funicular=yes"
    ]):

        name_no_city = strip_city_from_name(name, city)

        # ðŸ‘‡ DECISIONE PREFISSO
        if "bus=yes" in tag or "highway=bus_stop" in tag:
            prefix = "Fermata autobus"
        elif is_suburban_rail(name_no_city, tag_dict):
            prefix = "Fermata treno"
        elif "railway=station" in tag:
            prefix = "Stazione ferroviaria"
        elif "train=yes" in tag or "railway=stop" in tag:
            prefix = "Fermata treno"
        elif "subway=yes" in tag:
            prefix = "Stazione metropolitana"
        elif "funicular=yes" in tag:
            prefix = "Stazione funicolare"
        elif "tram=yes" in tag or "light_rail=yes" in tag:
            prefix = "Fermata tram"
        else:
            prefix = "Fermata"

        # ðŸ‘‡ Nomi inutili OSM â†’ sostituire con indirizzo
        meaningless_name_patterns = {
            "stop", "stop position", "stop_position",
            "platform", "piattaforma",
            "fermata", "bus stop", "halt"
        }

        base = normalize_for_match(name_no_city)
        is_meaningless_name = (base in meaningless_name_patterns or len(base) <= 3)

        if is_meaningless_name:
            toponimo = via_clean_short.strip()
            name = f"{prefix} {smart_capitalize(toponimo)}" if toponimo else prefix
        else:
            # Se il nome non contiene giÃ  il prefisso, aggiungilo
            if not name_no_city.lower().startswith(prefix.lower()):
                name = f"{prefix} {name_no_city}".strip()
            else:
                name = name_no_city.strip()

    # -----------------------------------
    # Parcheggi, bar, ecc. â†’ aggiungi indirizzo solo se non giÃ  specifico
    # -----------------------------------
     GENERIC_WITH_ADDRESS = {"bar","caffÃ¨","ristorante","parcheggio","supermercato","mercato","farmacia","banca","belvedere","pub"}
    base_name = name.lower()

    if any(base_name.startswith(g) for g in GENERIC_WITH_ADDRESS):
        if via_clean_short and not any(x in base_name for x in ["via","piazza","viale","corso","largo"]):
            name = f"{name} {smart_capitalize(via_clean_short)}"

    # -----------------------------------
    # Pulizia finale
    # -----------------------------------
    name = smart_capitalize(name).strip()
    name = fix_initials_in_name(name)

    poi["nome_poi"] = name
    poi["categoria_persistente"] = categoria.strip()
    poi["address"] = address.strip()
    return poi

  
def clean_list(pois):
    """
    Pulisce una lista di POI applicando le regole di normalizzazione del nome e delle categorie.
    """
    try:
#        from tqdm import tqdm
#        iterator = lambda x: tqdm(x, desc="Pulizia POI")
        iterator = lambda x: x  # disabilita temporaneamente tqdm per debug

    except Exception:
        iterator = lambda x: x

    cleaned = []
    total = len(pois)
    renamed = 0
    skipped = 0

    print(f"Avvio pulizia nomi per {total} POI...")

    for poi in iterator(pois):
        try:
            old_name = (poi.get("nome_poi") or poi.get("nome", "")).strip()

            poi = apply_name_cleaning(poi)
            new_name = (poi.get("nome_poi") or poi.get("nome", "")).strip()

            if new_name != old_name:
                renamed += 1
            else:
                skipped += 1

            for k, v in list(poi.items()):
                if v is None:
                    poi[k] = ""

            cleaned.append(poi)

        except Exception as e:
            print(f"Errore durante la pulizia di un POI (id={poi.get('poi_id','?')}): {e}")
            cleaned.append(poi)

    print(f"Pulizia completata")
    print(f"   â”œâ”€ POI totali: {total}")
    print(f"   â”œâ”€ Nomi modificati: {renamed}")
    print(f"   â””â”€ Nomi invariati: {skipped}")

    return cleaned
